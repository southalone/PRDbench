# Simplified Distributed File System PRD
## 1. Requirements Overview
This project aims to develop a distributed file system implemented using the Python standard library, featuring a three-tier architecture composed of client-proxy server-storage server. The system simulates a distributed environment using a local file system and inter-process communication, supporting concurrent multi-user access, enabling file permission management, basic caching mechanisms, and data redundancy, offering users a complete experience of distributed file storage services.
## 2. Basic Functional Requirements
### 2.1 User Connection and Session Management Module
Supports up to three client processes running simultaneously, with each client identified by a unique ID. Utilizes file locking mechanism to achieve inter-process communication and state synchronization, providing user identity authentication based on configuration files. The system provides the `login <username> <password>` command for user login. User identity authentication is based on configuration files stored in the config/ directory, containing username and password information. Session information is stored in a shared JSON file, supporting user login authentication and session state management. When the maximum number of clients is reached, the system should return the message "Maximum number of clients reached." Upon successful login, display "Login successful."; upon login failure, display corresponding error messages. Upon disconnection, automatically cleans up related resources and temporary files.
### 2.2 Core File Operation Module
Supports complete file lifecycle management, including file creation, reading, writing, deletion, and other core operations. The system provides the following commands: `create <filename> <permission>` for file creation, `read <filename>` for reading files, `write <filename> "<content>"` for writing files, `delete <filename>` for deleting files, `search <keyword>` for searching files, and `ls` for listing files. Allows users to specify file names and permission modes upon file creation, supporting four levels of permission settings. Upon successful file creation, display "File created successfully."; upon successful write, display "File written successfully."; upon successful deletion, display "File deleted successfully." When reading a file, display "--- Content of <filename> ---" followed by the file content. Implements basic file content editing functions, supporting complete reading and writing of text content. Provides file search feature, capable of searching local cache and all storage server locations. Supports file listing feature, displaying all files of a specified user and their distribution status.
### 2.3 Permission Management and Access Control Module
Implements four file access modes: full access allows complete access including deletion, writable permission allows read and write but not deletion, readonly permission supports file reading only, and private permission allows access only by file owner. Permission information is stored in configuration files, with permission verification performed before each file operation. Returns "Permission denied." error message when permission is insufficient, ensuring safe file access. The permission verification process should be recorded in the operation log, including user ID, operation type, target file, permission level, and verification result.
### 2.4 Simplified Concurrency Control Module
Uses file locking mechanism for inter-process synchronization, ensuring only one process is allowed to write to the same file at the same time. When a file is being written by another process, it should prompt an appropriate message indicating that the file is being written by another process and to retry later. Manages operation queue through temporary files in the `temp/` directory, generating operation queue temporary files (e.g., `queue_<filename>`) that record client ID, request timestamp, operation type, and other information, ensuring orderly execution of operations. Sets a 30-second operation timeout to prevent processes from occupying resources for an extended period, automatically releasing lock files after timeout. Supports concurrent execution of read operations, allowing multiple processes to read a file simultaneously if permissions permit.
### 2.5 Basic Cache Management Module
Each client maintains its own local cache directory to store copies of recently accessed files. The cache directory naming format is `clients/client{id}/cache/` or `clients/client_{PID}/cache/`, where id can be a client number or process ID. Implements a simple FIFO cache replacement strategy, with each client caching up to five files. Prioritizes checking local cache when reading files, returning local copies directly when cache hits occur, and records cache hit information in the operation log. Automatically updates the corresponding local cache content upon file write operations. Provides the `clear-cache` command for manually clearing local cache, displaying "Cache cleared." upon execution.
### 2.6 Data Redundancy and Fault Simulation Module
Automatically duplicates each file to two different storage server directories to ensure data redundancy. Simulates storage node health status monitoring by checking directory accessibility. Implements basic data recovery functions, automatically recovering data from other available copies when a specific replica is detected as unavailable, with recovery time not exceeding 10 seconds. Provides the `integrity` command for performing data integrity checks, verifying file existence and content integrity, displaying the replica consistency status for each file. Provides the `status` command for viewing system status, including active clients, storage server status, and file distribution.
### 2.7 System Management Module
Utilizes a fixed configuration of two storage server directory structures, manages system parameters through configuration files, which contain storage server list, maximum client count, cache capacity limit, operation timeout threshold, and other parameters. Provides the `config` command for viewing system configuration, displaying core parameters (storage server count, maximum client count, cache capacity limit, operation timeout threshold). Implements a simple file operation logging function, recording all file operations in the `logs/operations.log` text log file, with each log entry containing time, user ID, operation type, target file, result, and other information, supporting logging of operation types such as LOGIN_SUCCESS, CREATE_FILE, WRITE_FILE, READ_FILE, DELETE_FILE, LOGOUT. Provides the `status` command for system status queries, allowing viewing of current active clients (displaying "Active Sessions: X / 3" format), storage server status, and file distribution. Supports the `init` command for system initialization, creating necessary directory structures (clients/, servers/, config/, logs/, temp/, and servers/ must contain server1 and server2 subdirectories). Supports the `cleanup` command for system cleanup, deleting all user data (contents of servers/, clients/, logs/ directories) while preserving configuration files in the config/ directory. Provides the `logout` command for logging out and the `exit` command for exiting the system.
## 3. Data Requirements
### 3.1 File Storage Structure Design
Adopts a layered directory structure design, with client cache directories located at `clients/client{id}/cache/` or `clients/client_{PID}/cache/`, storage server directories at `servers/server{id}/{user_id}/`, and must include `servers/server1/` and `servers/server2/` storage server directories. System configuration files are stored in the `config/` directory, operation logs are recorded in the `logs/operations.log` file, and temporary files and lock files are stored in the `temp/` directory. File naming follows the `{owner_id}_{file_name}` format to ensure unique file identifiers. User ID can be generated through username mapping or using process-related unique identifiers.
### 3.2 Data Model Design
Access permissions are stored in JSON format, with keys as file identifiers and values as permission levels (full, writable, readonly, private). User information includes username and password. System configuration includes parameters such as storage server list, maximum client count, cache capacity limit, and operation timeout threshold. Session information includes client ID, username, login status (online/offline), and other information. File metadata records the file owner, creation time, size, and replica locations.
### 3.3 Inter-process Communication Protocol
Uses temporary files in JSON format for inter-process message transmission, with request and response files uniquely named using timestamps and client IDs. File locks are identified by resource names to prevent concurrent access conflicts. Operation queues are recorded through temporary files in the `temp/` directory, with file name format `queue_<filename>`, recording client ID, request timestamp, operation type, and other information. The communication protocol includes essential information such as operation type, user identity, target file, and operation parameters. The response format includes status code, message, and data content.
## 4. Performance and Reliability Requirements
### 4.1 Performance Indicators
The system supports up to three client processes to run concurrently, with a single file size limited to text files within 500KB. Local file operation response time is expected to be less than one second, aiming for a cache hit rate of over 60%. Each client's cache capacity is limited to five files, with a 30-second operation timeout. The total disk space usage of the system is controlled within 100MB.
### 4.2 Reliability Indicators
Maintains two replicas of each file to ensure no data loss in the event of single-point failures. Data recovery time is required to be completed within 10 seconds, with fault detection response time under 5 seconds. The system supports automatic recovery from single storage server failures, ensuring data consistency through synchronous write mechanisms. Operation logs fully document all file operations, supporting issue tracking and system auditing.
## 5. Technical Implementation Requirements
### 5.1 Development Environment Configuration
Programming language used is Python version 3.7 or above, completely implemented using the Python standard library with no dependencies on third-party packages. Core standard libraries used include `os` for file system operations, `json` for data serialization, `time` for time management, `threading` for concurrency control, and `fcntl` or `msvcrt` for file locking implementation. Supports cross-platform compatibilityâ€Œ, compatible with Windows, Linux, and macOS.
### 5.2 Deployment and Testing Requirements
The system uses a standalone deployment method, with all components operating on the same machine. Disk space requires at least 100MB, and each process requires at least 10MB of memory. Testing scope  includes multi-client concurrency testing, file access control testing, data redundancy and recovery testing, cache mechanism efficiency testing, etc. Supports automated test scripts to verify system functional  integrity and stability.