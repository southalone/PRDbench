[
  {
    "metric": "2.1.1 REPL Basic Startup Functionality: Correctly Start Interactive Environment via Command Line",
    "description": "1. **Arrange:** Prepare a terminal or command line window.\n2. **Act:** Execute the command `python src/repl.py` in the command line.\n3. **Assert:** Observe whether the REPL environment starts successfully and displays the prompt `>`.",
    "expected_output": "2 points: Program starts successfully and displays the correct prompt `>`. 1 point: Program starts but prompt is not `>` or displays abnormally. 0 points: Program fails to start or crashes immediately after startup."
  },
  {
    "metric": "2.1.2 REPL Read-Only Mode: Support Starting Read-Only Mode via Parameters",
    "description": "1. **Arrange:** Prepare a terminal or command line window.\n2. **Act:** Execute the command `python src/repl.py --read` in the command line.\n3. **Assert:** Observe whether read-only mode starts successfully, and whether parsing results are displayed instead of execution results when inputting expressions.",
    "expected_output": "2 points: Successfully starts read-only mode and correctly displays expression parsing results. 1 point: Can start read-only mode but parsing display is incomplete or has errors. 0 points: Unable to recognize --read parameter or read-only mode unavailable."
  },
  {
    "metric": "2.1.3a REPL Exit Functionality: Support Exiting Program via Ctrl+C",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Press Ctrl+C key combination.\n3. **Assert:** Observe whether program exits normally without error messages.",
    "expected_output": "2 points: Program exits immediately and normally after pressing Ctrl+C. 1 point: Requires multiple Ctrl+C presses to exit or error messages appear upon exit. 0 points: Ctrl+C cannot exit program."
  },
  {
    "metric": "2.1.3b REPL Exit Functionality: Support Exiting Program via Ctrl+D",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Press Ctrl+D key combination.\n3. **Assert:** Observe whether program exits normally without error messages.",
    "expected_output": "2 points: Program exits immediately and normally after pressing Ctrl+D. 1 point: Requires multiple Ctrl+D presses to exit or error messages appear upon exit. 0 points: Ctrl+D cannot exit program."
  },
  {
    "metric": "2.2.1a Lexical Analysis Number Support: Integer Recognition",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Input integer expressions `42` and `-7` sequentially.\n3. **Assert:** Verify whether interpreter can correctly recognize and return these integer values.",
    "expected_output": "2 points: Correctly recognizes and returns all tested integers, including negative numbers. 1 point: Only recognizes positive integers or recognition has errors. 0 points: Completely unable to recognize integers."
  },
  {
    "metric": "2.2.1b Lexical Analysis Number Support: Floating-Point Recognition",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Input floating-point expressions `3.14` and `-0.5` sequentially.\n3. **Assert:** Verify whether interpreter can correctly recognize and return these floating-point values.",
    "expected_output": "2 points: Correctly recognizes and returns all tested floating-point numbers, including negative numbers. 1 point: Only recognizes certain forms of floating-point numbers or recognition has errors. 0 points: Completely unable to recognize floating-point numbers."
  },
  {
    "metric": "2.2.2a Lexical Analysis Identifier Support: Ordinary Variable Name Recognition",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Input ordinary identifiers such as `x`, `var1`, etc.\n3. **Assert:** Observe whether interpreter can correctly recognize these identifiers (may prompt undefined, but should recognize as identifiers).",
    "expected_output": "2 points: Correctly recognizes all ordinary variable names. 1 point: Recognizes some variable names but certain cases have errors. 0 points: Unable to correctly recognize ordinary variable names."
  },
  {
    "metric": "2.2.2b Lexical Analysis Identifier Support: Underscore-Starting Identifiers",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Input underscore-starting identifiers such as `_y`, `_var2`, etc.\n3. **Assert:** Observe whether interpreter can correctly recognize these underscore-starting identifiers.",
    "expected_output": "2 points: Correctly recognizes all underscore-starting identifiers. 1 point: Recognizes some but certain cases have errors. 0 points: Unable to recognize underscore-starting identifiers."
  },
  {
    "metric": "2.2.3 Lexical Analysis Error Handling: Provide Detailed Syntax Error Prompts",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Input illegal characters such as `@#$` or unclosed parentheses such as `(1+2`.\n3. **Assert:** Observe whether error prompts containing error location and specific reason are provided.",
    "expected_output": "2 points: Error prompts contain specific error location (such as line number or character position) and clear reason description. 1 point: Provides error prompts but lacks location information or reason unclear. 0 points: No error prompts provided or directly crashes."
  },
  {
    "metric": "2.3.1a Syntax Analysis Basic Expression: Numeric Literals",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Input numeric literals such as `42` and `3.14`.\n3. **Assert:** Verify whether interpreter can correctly parse and return these numeric values.",
    "expected_output": "2 points: Correctly parses and returns all tested numeric literals. 1 point: Only parses certain numerical forms or parsing has errors. 0 points: Unable to correctly parse numeric literals."
  },
  {
    "metric": "2.3.1b Syntax Analysis Basic Expression: Name Expressions",
    "description": "1. **Arrange:** Start REPL environment and define variables (e.g., via lambda expressions or built-in functions).\n2. **Act:** Input defined variable names.\n3. **Assert:** Verify whether interpreter can correctly parse name expressions and return corresponding values.",
    "expected_output": "2 points: Correctly parses name expressions and returns variable values. 1 point: Recognizes variable names but returned values incorrect. 0 points: Completely unable to parse name expressions."
  },
  {
    "metric": "2.3.2a Syntax Analysis Call Expression: Basic Function Calls",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Input basic function calls such as `add(1, 2)`.\n3. **Assert:** Verify whether interpreter can correctly parse and execute the function call.",
    "expected_output": "2 points: Correctly parses and executes basic function calls. 1 point: Can parse but execution has errors or format requirements too strict. 0 points: Unable to parse basic function calls."
  },
  {
    "metric": "2.3.2b Syntax Analysis Call Expression: Nested Function Calls",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Input nested function calls such as `mul(add(1, 2), 3)`.\n3. **Assert:** Verify whether interpreter can correctly parse and execute nested function calls.",
    "expected_output": "2 points: Correctly parses and executes nested function calls of various complexities. 1 point: Can parse simple nesting but complex nesting has problems. 0 points: Completely unable to parse nested function calls."
  },
  {
    "metric": "2.3.3a Syntax Analysis Lambda Expression: Parameterless Lambda",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Input parameterless lambda expression such as `lambda: 42`.\n3. **Assert:** Verify whether interpreter can correctly parse the lambda expression.",
    "expected_output": "2 points: Correctly parses parameterless lambda expression. 1 point: Parsing has minor errors or requires specific format. 0 points: Unable to parse parameterless lambda expression."
  },
  {
    "metric": "2.3.3b Syntax Analysis Lambda Expression: Lambda with Parameters",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Input lambda expression with parameters such as `lambda x: add(x, 1)`.\n3. **Assert:** Verify whether interpreter can correctly parse the lambda expression.",
    "expected_output": "2 points: Correctly parses lambda expression with parameters. 1 point: Parsing has minor errors or requires specific format. 0 points: Unable to parse lambda expression with parameters."
  },
  {
    "metric": "2.4.1a Expression Evaluation Basic Operations: Addition and Subtraction",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Input expressions `add(1, 2)` and `sub(10, 5)`.\n3. **Assert:** Verify whether calculation results are 3 and 5 respectively.",
    "expected_output": "2 points: Both addition and subtraction operations calculate correctly. 1 point: Only one operation calculates correctly. 0 points: Both operations calculate incorrectly."
  },
  {
    "metric": "2.4.1b Expression Evaluation Basic Operations: Multiplication and Division",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Input expressions `mul(3, 4)` and `truediv(10, 2)`.\n3. **Assert:** Verify whether calculation results are 12 and 5 respectively.",
    "expected_output": "2 points: Both multiplication and division operations calculate correctly. 1 point: Only one operation calculates correctly. 0 points: Both operations calculate incorrectly."
  },
  {
    "metric": "2.4.2a Expression Evaluation Complex Operations: Nested Function Calls",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Input nested expression such as `add(mul(2, 3), truediv(8, 4))`.\n3. **Assert:** Verify whether calculation result is 8 (i.e., 6+2).",
    "expected_output": "2 points: Correctly executes three or more levels of nested calls. 1 point: Can execute two-level nesting but more complex nesting has problems. 0 points: Unable to handle any nested calls."
  },
  {
    "metric": "2.4.2b Expression Evaluation Complex Operations: Multi-Parameter Function Calls",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Input multi-parameter function call such as `max(1, 2, 3, 4, 5)`.\n3. **Assert:** Verify whether calculation result is 5.",
    "expected_output": "2 points: Correctly executes function calls with 3 or more parameters. 1 point: Only handles function calls with 2 parameters. 0 points: Unable to handle multi-parameter function calls."
  },
  {
    "metric": "2.4.3a Expression Evaluation Error Handling: Type Error Handling",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Input type error expression such as `add(1, lambda: 42)`.\n3. **Assert:** Verify whether clearly indicates type mismatch error information is provided.",
    "expected_output": "2 points: Provides detailed type error information, including expected type and actual type. 1 point: Indicates type error but information not detailed. 0 points: Does not report type error or directly crashes."
  },
  {
    "metric": "2.4.3b Expression Evaluation Error Handling: Undefined Variable Handling",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Input expressions referencing undefined variables such as `x` or `add(x, 1)`.\n3. **Assert:** Verify whether clearly indicates undefined variable error information is provided.",
    "expected_output": "2 points: Provides detailed undefined variable error information, including variable name. 1 point: Indicates undefined variable but information not detailed. 0 points: Does not report undefined error or directly crashes."
  },
  {
    "metric": "2.5.1a Built-in Functions Basic Arithmetic: Addition, Subtraction, Multiplication, Division",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Test `add(5, 3)`, `sub(5, 3)`, `mul(5, 3)`, and `truediv(6, 3)` sequentially.\n3. **Assert:** Verify whether calculation results are 8, 2, 15, and 2 respectively.",
    "expected_output": "2 points: All four basic arithmetic functions return correct results. 1 point: Two to three functions work normally. 0 points: Only zero to one function works normally."
  },
  {
    "metric": "2.5.1b Built-in Functions Basic Arithmetic: Integer Division, Modulo, Power",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Test `floordiv(7, 2)`, `mod(7, 3)`, and `pow(2, 3)` sequentially.\n3. **Assert:** Verify whether calculation results are 3, 1, and 8 respectively.",
    "expected_output": "2 points: All three functions return correct results. 1 point: One to two functions work normally. 0 points: No functions work normally."
  },
  {
    "metric": "2.5.2a Built-in Functions Advanced Arithmetic: Absolute Value and Extremes",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Test `abs(-5)`, `max(1, 5, 3)`, and `min(1, 5, 3)` sequentially.\n3. **Assert:** Verify whether calculation results are 5, 5, and 1 respectively.",
    "expected_output": "2 points: All three functions return correct results. 1 point: One to two functions work normally. 0 points: No functions work normally."
  },
  {
    "metric": "2.5.2b Built-in Functions Advanced Arithmetic: Type Conversion",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Test `int(3.14)` and `float(42)` sequentially.\n3. **Assert:** Verify whether calculation results are 3 and 42.0 respectively.",
    "expected_output": "2 points: Both type conversion functions return correct results. 1 point: Only one function works normally. 0 points: Both functions do not work normally."
  },
  {
    "metric": "2.6.1a Lambda Expressions Basic Definition: Parameterless Lambda",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Define and call parameterless lambda: `(lambda: 42)()`.\n3. **Assert:** Verify whether returned result is 42.",
    "expected_output": "2 points: Can correctly define and call parameterless lambda. 1 point: Definition correct but calling has problems. 0 points: Unable to define or call parameterless lambda."
  },
  {
    "metric": "2.6.1b Lambda Expressions Basic Definition: Single-Parameter Lambda",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Define and call single-parameter lambda: `(lambda x: add(x, 1))(5)`.\n3. **Assert:** Verify whether returned result is 6.",
    "expected_output": "2 points: Can correctly define and call single-parameter lambda. 1 point: Definition correct but calling has problems. 0 points: Unable to define or call single-parameter lambda."
  },
  {
    "metric": "2.6.2 Lambda Expressions Multiple Parameters: Support Multi-Parameter Lambda Definition",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Define and call multi-parameter lambda: `(lambda x, y: add(x, y))(3, 4)`.\n3. **Assert:** Verify whether returned result is 7.",
    "expected_output": "2 points: Can correctly define and call lambda functions with 2 or more parameters. 1 point: Syntax supported but parameter handling has problems. 0 points: Does not support multi-parameter lambda functions."
  },
  {
    "metric": "2.6.3 Lambda Expression Closure Feature: Support Capturing External Environment Variables",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Define nested lambda using external variable: `(lambda x: (lambda y: add(x, y)))(5)(3)`.\n3. **Assert:** Verify whether returned result is 8, proving inner lambda correctly captures outer lambda's parameter x.",
    "expected_output": "2 points: Fully supports closure feature, can correctly capture and use external variables. 1 point: Simple closures work but complex closures have problems. 0 points: Does not support closure or implementation severely flawed."
  },
  {
    "metric": "2.6.4a Lambda Expression Higher-Order Functions: Function as Parameter",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Test function as parameter: `(lambda f, x: f(x))(lambda y: add(y, 1), 5)`.\n3. **Assert:** Verify whether returned result is 6.",
    "expected_output": "2 points: Fully supports function as parameter feature. 1 point: Simple cases work but complex cases have problems. 0 points: Does not support function as parameter."
  },
  {
    "metric": "2.6.4b Lambda Expression Higher-Order Functions: Function as Return Value",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Test function as return value: `(lambda x: lambda y: add(x, y))(5)(3)`.\n3. **Assert:** Verify whether returned result is 8.",
    "expected_output": "2 points: Fully supports function as return value feature. 1 point: Simple cases work but complex cases have problems. 0 points: Does not support function as return value."
  },
  {
    "metric": "3.1 Friendly Error Prompts: Provide Chinese Error Prompts",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Intentionally input various error expressions, such as unclosed parentheses, undefined variables, type errors, etc.\n3. **Assert:** Verify whether error messages are in Chinese and clearly instructive.",
    "expected_output": "2 points: All tested error cases (at least 5 types) provide clear Chinese error prompts. 1 point: Some error prompts in Chinese or not clear enough (2-4 types). 0 points: Error prompts all in English or not instructive (0-1 type in Chinese)."
  },
  {
    "metric": "3.2 Formatted Output: Formatted Display of Results and Error Information",
    "description": "1. **Arrange:** Start REPL environment.\n2. **Act:** Execute various correct expressions and error operations, observe output format.\n3. **Assert:** Verify whether output is standardized, consistent, and easy to read.",
    "expected_output": "2 points: All outputs have consistent format, clear and easy to read, error information clearly distinguished from normal output. 1 point: Basically readable but format inconsistent or not aesthetic. 0 points: Output chaotic and difficult to read."
  },
  {
    "metric": "3.3 Debug Mode: Support Viewing Expression's Python Representation",
    "description": "1. **Arrange:** Start REPL read-only mode: `python src/repl.py --read`.\n2. **Act:** Input complex expression such as `lambda x: add(mul(x, 2), 3)`.\n3. **Assert:** Verify whether expression's Python internal representation is displayed.",
    "expected_output": "2 points: Read-only mode completely displays expression's Python representation, including all syntax structures and nesting relationships. 1 point: Displays partial representation but information incomplete. 0 points: Does not provide expression's Python representation functionality."
  }
]