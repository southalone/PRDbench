[
  {
    "metric": "1.1.1 Main Menu Function Navigation: After program startup, the main menu is correctly displayed, and corresponding functional modules can be accessed via numeric options.",
    "description": "Start the program. Observe if a menu clearly displaying '[1] Enter CSV File Path', '[2] SQL Query', '[3] Screen Stocks', '[4] Analyze Metric Fluctuation', '[5] View History Queries', '[6] Exit' is shown. Input 1, 2, 3, 4, 5, 6 sequentially, verifying if the program enters the corresponding functional module or exits correctly after each input.",
    "expected_output": "2 points: Main menu clearly displays all 6 options, and inputs 1-6 all correctly respond, entering the respective function or exiting normally. 1 point: Menu display is incomplete or contains typos, or 1-2 options do not work correctly. 0 points: No menu appears after program startup, or more than 2 options are invalid, or the program crashes."
  },
  {
    "metric": "1.1.2 Input Validity Check: Strictly validates input for the main menu.",
    "description": "On the main menu interface, input non-numeric characters (e.g., 'a') and out-of-range numbers (e.g., '0' or '7') sequentially. Observe if the program can catch the errors and provide clear Chinese prompts (e.g., \"Error: Please enter a number between 1 and 6\") without crashing, remaining on the main menu screen.",
    "expected_output": "2 points: Provides clear, accurate Chinese error prompts for all invalid inputs (non-numeric, out-of-range) and maintains program stability. 1 point: Can catch errors but prompts are unclear or in English, or only handles some types of invalid input (e.g., only handles out-of-range, not non-numeric). 0 points: Any invalid input causes the program to crash or become unresponsive."
  },
  {
    "metric": "1.2.1 CSV Data Source Configuration: Supports users configuring local CSV file paths via the command line.",
    "description": "1. Precondition Check (User Path): From the main menu, can the user clearly enter the 'Enter CSV File Path' function interface by inputting '[1]' and pressing Enter?\n2. Preparation: Prepare a real existing CSV file (e.g., /path/to/data.csv) and a non-existent path (e.g., /path/to/fake.csv).\n3. Execution (Valid Path): After entering the function, input the real path and submit.\n4. Assertion (Valid Path): The program should clearly prompt 'Configuration successful' or similar information.\n5. Execution (Invalid Path): Enter the function again, input the non-existent path and submit.\n6. Assertion (Invalid Path): The program should clearly prompt 'File not found' or 'Invalid path', and must continue running without crashing.",
    "expected_output": "2 points: Precondition check passes, successfully configures the valid path, and provides clear Chinese error prompts for invalid/non-existent paths. 1 point: Precondition check passes, but provides no prompt or unclear prompts for invalid paths, or the program errors in subsequent steps after configuring a valid path. 0 points: Precondition check fails, or the function is completely unusable."
  },
  {
    "metric": "2.1.1 Multi-line SQL Input and Execution: Supports entry and combined execution of multi-line SQL statements.",
    "description": "1. Precondition Check (User Path): From the main menu, can the user clearly enter the 'SQL Query' function interface by inputting '[2]' and pressing Enter?\n2. Preparation: Enter the SQL query interface.\n3. Execution: Input the following three lines sequentially, pressing Enter after each line:\n   'SELECT Ticker, CompanyName'\n   'FROM stocks'\n   'WHERE Industry = \"Technology\";'\n   Finally, submit for execution (e.g., via an empty line or specific command).\n4. Assertion: The program should merge the three lines into a single complete SQL statement and execute it successfully, returning the query results.",
    "expected_output": "2 points: Precondition check passes, fully supports multi-line input, correctly concatenates into a single SQL for execution without requiring a special terminator. 1 point: Precondition check passes, supports multi-line input but requires special action (e.g., input 'go' or ';;') to submit, or occasional concatenation errors may occur. 0 points: Precondition check fails, or does not support multi-line input (each line is treated as a separate command)."
  },
  {
    "metric": "2.1.2 Basic SQL Syntax Validation: Performs basic syntax validation on input SQL based on `sqlparse`.",
    "description": "1. Precondition Check (User Path): From the main menu, can the user clearly enter the 'SQL Query' function interface by inputting '[2]' and pressing Enter?\n2. Execution (Unmatched Parentheses): Input 'SELECT * FROM stocks WHERE (Industry = \"Technology\"' and attempt execution.\n3. Assertion (Unmatched Parentheses): The program should catch the error and prompt 'Syntax error: Unmatched parentheses' or similar, rather than sending the SQL to the backend.\n4. Execution (Keyword Error): Input 'SELEKT * FROM stocks' and attempt execution.\n5. Assertion (Keyword Error): The program should catch the error and prompt 'Syntax error: Unrecognized keyword SELEKT' or similar.",
    "expected_output": "2 points: Precondition check passes, accurately identifies and prompts for both basic syntax issues: keyword errors and unmatched parentheses. 1 point: Precondition check passes, but only identifies one type of issue, or the prompt is vague (e.g., only 'Syntax error'). 0 points: Precondition check fails, or performs no syntax validation (directly passes erroneous SQL to the backend for execution)."
  },
  {
    "metric": "2.1.3 Query Interrupt Function: Supports users interrupting ongoing queries via Ctrl+C.",
    "description": "1. Precondition Check (User Path): From the main menu, can the user clearly enter the 'SQL Query' function interface by inputting '[2]' and pressing Enter?\n2. Preparation: Execute a time-consuming query (e.g., an unindexed query on a very large dataset).\n3. Execution: Immediately after the program displays 'Querying...' or similar progress information, press the Ctrl+C key combination.\n4. Assertion: The program should immediately terminate the query, print 'Query interrupted' or similar, and stably return to the SQL query menu or main menu, without crashing or exiting.",
    "expected_output": "2 points: Precondition check passes, program captures the Ctrl+C signal, immediately stops the query, provides a clear prompt, and maintains program stability. 1 point: Precondition check passes, program stops the query but exits directly, or requires multiple key presses to interrupt, or provides no interrupt prompt. 0 points: Precondition check fails, or Ctrl+C is ineffective, or causes program crash."
  },
  {
    "metric": "2.1.4a Query Failure Reason Prompt (Non-existent Field): Returns specific reason when a queried field does not exist.",
    "description": "1. Precondition Check (User Path): From the main menu, can the user clearly enter the 'SQL Query' function interface by inputting '[2]' and pressing Enter?\n2. Preparation: Successfully configured a CSV data source containing the 'Ticker' field.\n3. Execution: Execute the SQL query 'SELECT NonExistentField FROM stocks'.\n4. Assertion: The error message returned by the program should clearly indicate 'Field does not exist' or 'Invalid column name: NonExistentField'.",
    "expected_output": "2 points: Precondition check passes, clearly prompts 'Field does not exist' or similar information containing the specific erroneous field name. 1 point: Precondition check passes, prompts query failure but the error message is generic (e.g., 'Query failed' or 'SQL execution error'), user cannot directly identify it as a field issue. 0 points: Precondition check fails, or program crashes or provides no prompt after query failure."
  },
  {
    "metric": "2.1.4b Query Failure Reason Prompt (Data Source Not Configured): Returns specific reason when no data source is configured.",
    "description": "1. Precondition Check (User Path): From the main menu, can the user clearly enter the 'SQL Query' function interface by inputting '[2]' and pressing Enter?\n2. Preparation: Ensure no CSV data source is configured after program startup.\n3. Execution: Directly enter the SQL query function and execute any valid SQL, e.g., 'SELECT * FROM stocks'.\n4. Assertion: The error message returned by the program should clearly indicate 'Data source not configured' or 'Please configure CSV file path first'.",
    "expected_output": "2 points: Precondition check passes, clearly prompts 'Data source not configured' or similar information. 1 point: Precondition check passes, prompts query failure but the error message is generic (e.g., 'Query failed'), user cannot directly identify it as a data source issue. 0 points: Precondition check fails, or program crashes or provides no prompt after query failure."
  },
  {
    "metric": "2.1.5a History Query Recording and Display: Automatically saves the last 10 valid queries and supports viewing them.",
    "description": "1. Precondition Check (User Path): From the main menu, can the user clearly enter the 'View History Queries' function interface by inputting '[5]' and pressing Enter?\n2. Preparation: In the SQL query function, execute 3 different valid SQL statements consecutively.\n3. Execution: Enter the 'View History Queries' function.\n4. Assertion: The program should list the 3 historical SQL records with numbers, in the correct order (most recent query has the smallest number, e.g., number 1).",
    "expected_output": "2 points: Precondition check passes, correctly saves and completely displays the last 3 executed queries in order from most recent to oldest. 1 point: Precondition check passes, but displayed records are incomplete (less than 3), order is wrong, or format is messy. 0 points: Precondition check fails, or unable to view history records."
  },
  {
    "metric": "2.1.5b History Query Reuse: Supports reusing historical queries by inputting their number.",
    "description": "1. Precondition Check (User Path): From the main menu, can the user clearly enter the 'View History Queries' function interface by inputting '[5]' and pressing Enter?\n2. Preparation: At least 2 different valid SQL statements have been executed, and the history query list interface is entered.\n3. Execution: According to the list prompt, input number '2' (representing the second last executed SQL) and submit.\n4. Assertion: The program should automatically execute the historical SQL numbered 2 and return exactly the same query results as when it was originally executed.",
    "expected_output": "2 points: Precondition check passes, accurately re-executes the corresponding historical SQL based on the user's valid input number. 1 point: Precondition check passes, but the reuse function has bugs, e.g., executes the wrong number, or errors during execution. 0 points: Precondition check fails, or the reuse function is completely ineffective."
  },
  {
    "metric": "2.2.1 Preset Market Cap Tier Screening: Based on query results, can screen according to preset market cap categories.",
    "description": "1. Precondition Check (User Path): After a successful SQL query, can the user clearly enter the 'Screen Stocks' function interface by inputting '[3]' and pressing Enter from the main menu?\n2. Preparation: Execute an SQL query ensuring the result contains a 'MarketCap' field and data covering multiple market cap tiers.\n3. Execution: After entering the screening function, select the preset 'Large-Cap' category for screening.\n4. Assertion: Verify if the 'MarketCap' value for all stocks in the output results is greater than or equal to 10,000,000,000 (10 billion).",
    "expected_output": "2 points: Precondition check passes, provides all preset options (e.g., Large, Mid, Small-Cap), and screening results fully comply with the PRD's market cap definitions for each tier. 1 point: Precondition check passes, but screening results are inaccurate (e.g., boundary value errors), or some preset options are missing. 0 points: Precondition check fails, or the function is completely unusable."
  },
  {
    "metric": "2.2.2 Custom Market Cap Range Screening: Supports users inputting custom market cap lower and upper limits for screening.",
    "description": "1. Precondition Check (User Path): After a successful SQL query, can the user clearly enter the 'Screen Stocks' function interface by inputting '[3]' and pressing Enter from the main menu, and find the 'Custom Range' option?\n2. Preparation: Execute an SQL query ensuring the result contains a 'MarketCap' field.\n3. Execution: In the screening function, select the custom market cap range, and input the lower limit '5000000000' and the upper limit '8000000000'.\n4. Assertion: Verify if the 'MarketCap' value for all stocks in the output results is >= 5000000000 and <= 8000000000.",
    "expected_output": "2 points: Precondition check passes, allows user to input lower/upper limits, and screening results strictly match the input closed interval numerical range. 1 point: Precondition check passes, but the range judgment is erroneous (e.g., open/closed interval error, greater/less than signs reversed) or cannot handle large numbers. 0 points: Precondition check fails, or the function is completely unusable."
  },
  {
    "metric": "2.2.3a Combined Logic Screening (AND Logic): Supports adding other dimensions for 'AND' logic screening based on market cap screening.",
    "description": "1. Precondition Check (User Path): In the screening function, can the user find the option to add extra screening conditions?\n2. Preparation: Execute an SQL query ensuring the result contains 'MarketCap' and 'Industry' fields.\n3. Execution: First select 'Large-Cap' for screening, then choose to add a condition, screen the 'Industry' field for 'Technology', and explicitly use 'AND' logic.\n4. Assertion: Verify if all stocks in the result set simultaneously satisfy both conditions: MarketCap >= 10 billion AND Industry == 'Technology'.",
    "expected_output": "2 points: Precondition check passes, can smoothly add multiple screening conditions and correctly implement 'AND' logic. 1 point: Precondition check passes, but 'AND' logic implementation is flawed, or the interaction for adding conditions is unclear. 0 points: Precondition check fails, or does not support combined screening with 'AND' logic."
  },
  {
    "metric": "2.2.3b Combined Logic Screening (OR Logic): Supports 'OR' logic screening between different dimensions.",
    "description": "1. Precondition Check (User Path): In the screening function, can the user find the option to add extra screening conditions and select 'OR' logic?\n2. Preparation: Execute an SQL query ensuring the result contains the 'Industry' field.\n3. Execution: Do not perform market cap screening. Directly add a condition, screen the 'Industry' field for 'Technology', then add another condition screening for 'Healthcare', and explicitly use 'OR' logic.\n4. Assertion: Verify if the value of the 'Industry' field for all stocks in the result set is either 'Technology' or 'Healthcare'.",
    "expected_output": "2 points: Precondition check passes, can smoothly add multiple screening conditions and correctly implement 'OR' logic. 1 point: Precondition check passes, but 'OR' logic implementation is flawed, or the interaction is unclear. 0 points: Precondition check fails, or does not support combined screening with 'OR' logic."
  },
  {
    "metric": "2.2.4a Result Pagination Display: Screening results can be displayed in pages, 10 items per page.",
    "description": "1. Precondition Check (User Path): For query/screening results exceeding 10 items, does the program automatically enable pagination and provide clear instructions for page navigation?\n2. Preparation: Obtain a screening result with over 15 records.\n3. Execution & Assertion 1 (First Page): Verify if the program by default only displays the first 10 records.\n4. Execution & Assertion 2 (Next Page): Perform a page turn operation according to the prompt (e.g., 'Input n for next page'), verify if records 11-15 can be seen.",
    "expected_output": "2 points: Precondition check passes, automatically paginates long results (10 items per page), and previous/next page navigation functions are fully usable. 1 point: Precondition check passes, but pagination function has defects (e.g., items per page not 10, page number calculation error, cannot turn pages). 0 points: Precondition check fails, or no pagination function."
  },
  {
    "metric": "2.2.4b Result Sorting Function: Screening results support ascending/descending sorting by specified fields.",
    "description": "1. Precondition Check (User Path): For query/screening results, does the program provide an option to sort by field?\n2. Preparation: Obtain a screening result containing the 'MarketCap' field.\n3. Execution: According to the prompt, choose to sort by the 'MarketCap' field in descending order.\n4. Assertion: Verify if the 'MarketCap' values of the output results on the first page are strictly arranged in order from high to low.",
    "expected_output": "2 points: Precondition check passes, allows user to select field and correctly perform both ascending and descending sorting. 1 point: Precondition check passes, but sorting function has defects (e.g., only ascending, incorrect sort results, not all sortable fields available). 0 points: Precondition check fails, or no sorting function."
  },
  {
    "metric": "2.3.1 Target Metric Selection for Analysis: Allows user to select one numerical field from query results as the analysis target.",
    "description": "1. Precondition Check (User Path): After a successful SQL query, can the user clearly enter the 'Analyze Metric Fluctuation' function interface by inputting '[4]' and pressing Enter from the main menu?\n2. Preparation: Execute an SQL query where the result contains numerical fields (e.g., 'MarketCap', 'PE') and non-numerical fields (e.g., 'Industry').\n3. Execution: Enter the first step of the analysis function.\n4. Assertion: Does the program automatically list, and only list, all numerical fields ('MarketCap', 'PE') for user selection by number, excluding 'Industry'?",
    "expected_output": "2 points: Precondition check passes, automatically and accurately identifies and lists all numerical fields for user selection. 1 point: Precondition check passes, but listed fields are incomplete (missing numerical) or inaccurate (including non-numerical). 0 points: Precondition check fails, or unable to select metric, or this step is missing."
  },
  {
    "metric": "2.3.2 Analysis Dimension Selection: Automatically extracts non-numerical fields as candidate dimensions and supports user selection.",
    "description": "1. Precondition Check (User Path): After selecting the target metric, does the program automatically enter the analysis dimension selection interface?\n2. Preparation: Based on the previous step, a target metric has been selected. The query result contains non-numerical fields (e.g., 'Industry', 'Region') and numerical fields (e.g., 'PE').\n3. Execution: Observe the candidate analysis dimensions listed by the program.\n4. Assertion: Does the program automatically list, and only list, all non-numerical fields ('Industry', 'Region') as candidates, and support user selection of multiple ones via a format like '1,2'?",
    "expected_output": "2 points: Precondition check passes, automatically and accurately identifies and lists all non-numerical fields as candidates, and supports user selection of one or multiple. 1 point: Precondition check passes, but candidate dimension identification is inaccurate (missing or including numerical), or the interaction for user selection of multiple dimensions has issues. 0 points: Precondition check fails, or unable to select dimensions, or this step is missing."
  },
  {
    "metric": "2.3.3 Variance Decomposition Contribution Calculation and Display: Correctly calculates and outputs the contribution of each dimension and interaction effects to metric fluctuation.",
    "description": "1. Precondition Check (User Path): After selecting the metric and dimensions, can the program successfully execute the analysis and display results?\n2. Preparation: Select a metric (e.g., 'PE') and at least two dimensions (e.g., 'Industry', 'Region') for analysis.\n3. Execution: Trigger the analysis calculation.\n4. Assertion: Observe if the output contains variance explained proportion information, with clear formatting, e.g.: 'Dimension Contribution:\\n- Industry: 42.0%\\n- Region: 28.0%\\n- Interaction Effect (Industry*Region): 15.0%\\n- Residual: 15.0%'",
    "expected_output": "2 points: Precondition check passes, correctly outputs the contribution percentage of each selected dimension and interaction effects to the metric's variance, and the sum of all items (including residual) is approximately 100%. 1 point: Precondition check passes, outputs results but lacks calculation of interaction effects, or the sum of items deviates too much from 100% (e.g., more than Â±5%). 0 points: Precondition check fails, or unable to output contribution results."
  },
  {
    "metric": "2.3.4 Core Dimension In-depth Analysis: Drills down into the dimension with the highest contribution, displaying sub-category statistical information.",
    "description": "1. Precondition Check (User Path): After the variance decomposition results are displayed, does the program automatically trigger or provide an option for in-depth analysis?\n2. Preparation: Perform a variance decomposition ensuring one dimension's contribution exceeds 30% (e.g., 'Industry' contributes 42%).\n3. Execution: Observe the output below the variance decomposition results.\n4. Assertion: Does the program automatically perform in-depth analysis on the 'Industry' dimension and output the metric's statistical information (mean and standard deviation) for its sub-categories (e.g., 'Technology', 'Healthcare')?",
    "expected_output": "2 points: Precondition check passes, automatically identifies the dimension with the highest contribution (if >30%) and accurately outputs the mean and standard deviation for its sub-categories. 1 point: Precondition check passes, performs in-depth analysis but output information is incomplete (e.g., missing standard deviation), or does not trigger automatically (requires additional complex operations). 0 points: Precondition check fails, or no in-depth analysis function."
  },
  {
    "metric": "2.4.1 Textual Table Display of Results: Analysis results support display via formatted text tables.",
    "description": "1. Preparation: Perform a screening to obtain a result set with multiple rows and columns.\n2. Execution: Before result output, observe if the program asks the user 'Display results in table format? [y/n]'.\n3. Assertion: After selecting 'y', is the output content a well-aligned, column-width adaptive, easy-to-read text table (similar to `pretty-table` effect)? Selecting 'n' outputs raw data.",
    "expected_output": "2 points: For multi-row, multi-column results, proactively asks the user and, based on the choice, generates a neatly formatted, well-aligned text table. 1 point: Provides tabular function but requires user invocation via specific command (not smart enough), or the generated table format is messy and poorly readable. 0 points: No such option is provided, results are always output flatly."
  },
  {
    "metric": "2.4.2a Report Saving Function: Supports saving analysis results as a TXT file.",
    "description": "1. Precondition Check (User Path): After completing a full analysis process, does the program provide a 'Save Report' option?\n2. Preparation: Complete one 'Query-Screen-Analyze' process.\n3. Execution: In the final step, choose to save the report, and input the filename 'report.txt' as prompted.\n4. Assertion: The program prompts 'Report successfully saved to report.txt', and the file is indeed generated in the current directory.",
    "expected_output": "2 points: Precondition check passes, successfully creates and saves the TXT file according to the user-specified name. 1 point: Precondition check passes, but the save function is unstable, or the filename cannot be customized. 0 points: Precondition check fails, or the save function is ineffective, or the program crashes during saving."
  },
  {
    "metric": "2.4.2b Report Content Verification (Context): The report file must contain complete analysis context information.",
    "description": "1. Preparation: The 'report.txt' file has been generated.\n2. Execution: Use `cat report.txt` or a text editor to view the file content.\n3. Assertion: Check if the file content contains the following two parts: 1) The originally executed SQL statement; 2) The applied screening conditions (e.g., 'Market Cap Category: Large-Cap').",
    "expected_output": "2 points: The report fully contains the executed SQL and all screening conditions. 1 point: The report contains only one of the SQL or screening conditions, or the information is incomplete. 0 points: The report completely lacks context information like SQL and screening conditions."
  },
  {
    "metric": "2.4.2c Report Content Verification (Analysis Results): The report file must contain the complete analysis process and conclusions.",
    "description": "1. Preparation: The 'report.txt' file has been generated.\n2. Execution: Use `cat report.txt` or a text editor to view the file content.\n3. Assertion: Check if the file content contains the following three parts: 1) The selected analysis metric and dimensions; 2) The variance decomposition contribution data; 3) The final in-depth analysis results table.",
    "expected_output": "2 points: The report fully contains these three core analysis pieces of information: analysis metric/dimensions, contribution data, in-depth analysis results. 1 point: The report is missing 1-2 of the core analysis pieces of information. 0 points: The report completely lacks the core analysis information."
  }
]